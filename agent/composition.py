"""Composition data structures for agent orchestration.

This module defines the composition patterns and plans that enable
ReactAgent to dynamically compose complex behaviors through delegation.
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional, Set


class CompositionPattern(Enum):
    """Patterns for composing agent behavior."""

    NONE = "none"  # Direct execution, no decomposition
    PLAN_EXECUTE = "plan_execute"  # Explore → Plan → Execute → Synthesize
    PARALLEL_EXPLORE = "parallel_explore"  # Parallel exploration of aspects
    SEQUENTIAL_DELEGATE = "sequential_delegate"  # Sequential subtask delegation


@dataclass
class SubtaskSpec:
    """Specification for a subtask to be delegated.

    Attributes:
        description: Clear description of what the subtask should accomplish
        tool_filter: Optional set of tool names to restrict available tools
        inherit_context: Whether to inherit parent's memory context
        priority: Execution priority (lower = higher priority)
        depends_on: List of subtask IDs this subtask depends on
    """

    description: str
    tool_filter: Optional[Set[str]] = None
    inherit_context: bool = True
    priority: int = 0
    depends_on: List[str] = field(default_factory=list)
    id: str = ""  # Assigned by the composition system

    def __post_init__(self):
        if not self.id:
            # Generate a simple ID based on description hash
            self.id = f"subtask_{hash(self.description) % 10000:04d}"


@dataclass
class ExplorationAspect:
    """A single aspect to explore during the exploration phase.

    Attributes:
        name: Short identifier for the aspect (e.g., "api_patterns")
        description: What to explore and why
        focus_areas: Specific areas or questions to focus on
        tool_filter: Tools to use for this exploration (read-only by default)
    """

    name: str
    description: str
    focus_areas: List[str] = field(default_factory=list)
    tool_filter: Optional[Set[str]] = field(
        default_factory=lambda: {"glob_files", "grep_content", "read_file", "code_navigator"}
    )


@dataclass
class CompositionPlan:
    """Plan for how to compose agent behavior for a task.

    This is generated by _assess_composition_need() and consumed by
    composition executors like _execute_plan_pattern().

    Attributes:
        should_compose: Whether to decompose the task
        pattern: Which composition pattern to use
        exploration_aspects: Dynamic list of aspects to explore
        subtasks: List of subtasks to execute
        reasoning: LLM's reasoning for this composition decision
        metadata: Additional context from the assessment
    """

    should_compose: bool
    pattern: CompositionPattern
    exploration_aspects: List[ExplorationAspect] = field(default_factory=list)
    subtasks: List[SubtaskSpec] = field(default_factory=list)
    reasoning: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)

    @classmethod
    def direct_execution(cls) -> "CompositionPlan":
        """Create a plan for direct execution without composition."""
        return cls(
            should_compose=False,
            pattern=CompositionPattern.NONE,
            reasoning="Task is simple enough for direct execution",
        )

    @classmethod
    def plan_execute(
        cls,
        exploration_aspects: List[ExplorationAspect],
        reasoning: str = "",
    ) -> "CompositionPlan":
        """Create a plan-execute composition plan.

        Args:
            exploration_aspects: Aspects to explore before planning
            reasoning: Why this pattern was chosen
        """
        return cls(
            should_compose=True,
            pattern=CompositionPattern.PLAN_EXECUTE,
            exploration_aspects=exploration_aspects,
            reasoning=reasoning,
        )

    @classmethod
    def parallel_explore(
        cls,
        aspects: List[ExplorationAspect],
        reasoning: str = "",
    ) -> "CompositionPlan":
        """Create a parallel exploration composition plan.

        Args:
            aspects: Aspects to explore in parallel
            reasoning: Why this pattern was chosen
        """
        return cls(
            should_compose=True,
            pattern=CompositionPattern.PARALLEL_EXPLORE,
            exploration_aspects=aspects,
            reasoning=reasoning,
        )


@dataclass
class CompositionResult:
    """Result from executing a composition plan.

    Attributes:
        success: Whether the composition completed successfully
        final_answer: The synthesized final answer
        exploration_results: Results from exploration phase
        step_results: Results from each execution step
        metadata: Additional execution metadata
    """

    success: bool
    final_answer: str = ""
    exploration_results: Dict[str, str] = field(default_factory=dict)
    step_results: List[Dict[str, Any]] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class AgentConfig:
    """Configuration for spawning a new agent.

    Attributes:
        task: The task for this agent to accomplish
        tools: List of tools available to this agent
        memory_node_id: ID of the memory node for this agent's context
        role_prompt: Optional role-specific system prompt
        tool_filter: Optional filter to restrict available tools
        inherit_context: Whether to inherit parent context
        depth: Current nesting depth of this agent
    """

    task: str
    tools: List[Any]  # List[BaseTool]
    memory_node_id: str
    role_prompt: str = ""
    tool_filter: Optional[Set[str]] = None
    inherit_context: bool = True
    depth: int = 0

    def get_filtered_tools(self) -> List[Any]:
        """Get tools filtered by tool_filter if specified."""
        if self.tool_filter is None:
            return self.tools
        return [t for t in self.tools if t.name in self.tool_filter]
